/*
Copyright (C) 2013-2017 Huawei Technologies Co., Ltd. All rights reserved.
*/
module huawei-acl {
  namespace "http://www.huawei.com/netconf/vrp/huawei-acl";
  prefix acl;
  import huawei-l3vpn {
    prefix l3vpn;
  }
  import huawei-pub-type {
    prefix pub-type;
  }
  import huawei-timerange {
    prefix timerange;
  }
  import ietf-inet-types {
    prefix inet;
  }
  import huawei-extension {
    prefix ext;
  }
  include huawei-acl-action;
  include huawei-acl-type;
  
  organization
    "Huawei Technologies Co.,Ltd.";
  contact
    "Huawei Industrial Base Bantian, Longgang Shenzhen 518129                    
        People's Republic of China                    
        Website: http://www.huawei.com Email: support@huawei.com";
  description
    "Access Control List (ACL). An ACL is used to identify and select data packets through packet attributes. For example, applying an ACL in the firewall can either permit or discard data packets. Applying an ACL in IPsec can encrypt data packets that match ACL rules and forward those that do not match any ACL rule.";
  revision 2017-03-23 {
    description
      "Functions supported by the schema are added to the YANG file.";
    reference
      "Huawei private.";
  }
  revision 2013-01-01 {
    description
      "Init revision";
    reference
      "Huawei private.";
  }
  container acl {
    description
      "Access Control List (ACL). An ACL is used to identify and select data packets through packet attributes. For example, applying an ACL in the firewall can either permit or discard data packets. Applying an ACL in IPsec can encrypt data packets that match ACL rules and forward those that do not match any ACL rule.";
    container aclGroups {
      description
        "List of all ACL rule groups.";
      list aclGroup {
        key "aclNumOrName";
        description
          "ACL rule group, which is a collection of rules. Other features can use the ACL control by referring to the ACL rule group name.";
        leaf aclNumOrName {
          type pub-type:aclNumOrName {
            length "1..32";
            pattern '([1-5]\d{3})|(10[0-9]{3})|(23[0-9]{3})|(99999)|([a-zA-Z]([^\s]*))';
          }
          description
            "ACL number or name. An ACL number ranges from 1000 to 5999 or 10000 to 10999 or 23000 to 23999. An ACL name must start with a letter, spaces not supported. The number of an interface-based ACL ranges from 1000 to 1999. The number of a basic ACL ranges from 2000 to 2999. The number of an advanced ACL ranges from 3000 to 3999, and an advanced ACL can start with a letter. The number of an Ethernet frame header-based ACL ranges from 4000 to 4999. The number of a user-defined ACL ranges from 5000 to 5999. The number of an MPLS-based ACL ranges from 10000 to 10999.The number of an ARP-based ACL ranges from 23000 to 23999.
 ";
          ext:support-filter "true";
        }
        leaf aclType {
          type acl4GroupType;
          description
            "ACL Type.";
          ext:support-filter "true";
        }
        leaf aclNumber {
          type uint32 {
            range "2000..23999";
          }
          must "(../aclType='ARP' and ../aclNumber>=23000 and ../aclNumber<=23999) or (../aclType='Advance' and ../aclNumber>=3000 and ../aclNumber<=3999) or (../aclType='Basic' and ../aclNumber>=2000 and ../aclNumber<=2999) or (../aclType='Link' and ../aclNumber>=4000 and ../aclNumber<=4999) or (../aclType='User' and ../aclNumber>=5000 and ../aclNumber<=5999) or not(../aclType='ARP' or ../aclType='Advance' or ../aclType='Basic' or ../aclType='Link' or ../aclType='User')";
          description
            "ACL number.";
          ext:support-filter "true";
        }
        leaf aclStep {
          type uint32 {
            range "1..20";
          }
          default "5";
          description
            "Step of an ACL rule.";
          ext:allowDelete "true";
        }
        leaf aclDescription {
          type string {
            length "1..127";
            pattern '[^\?\s](([^\?\s]*)|[^\t\?]*[^\?\s])';
          }
          description
            "ACL description. The value cannot begin or end with a space.";
          ext:allowDelete "true";
        }
        container aclRuleBas4s {
          description
            "List of basic ACL rules. The basic ACL rule group where these rules reside is of the numeric type or name type. For the basic ACL rule group of the numeric type, the value ranges from 2000 to 2999.";
          list aclRuleBas4 {
            key "aclRuleName";
            description
              "Basic ACL rule, used to permit or deny packets. Other features can use these rules through a rule group to match source IP addresses.";
            leaf aclRuleName {
              type string {
                length "1..32";
                pattern '[^\s\?]*';
              }
              must "../../../aclType = 'Basic'";
              description
                "Name of a basic ACL rule. The rule name can be a number or character string without spaces, but cannot start with an underscore (_).";
            }
            leaf aclRuleID {
              type uint32 {
                range "0..4294967294";
              }
              description
                "ID of a basic ACL rule in configuration mode.";
              ext:support-filter "true";
            }
            leaf aclAction {
              type aclRuleAction;
              mandatory true;
              description
                "Matching mode of basic ACL rules. The available options are Permit and Deny.";
              ext:support-filter "true";
            }
            leaf aclActiveStatus {
              type pub-type:rowStatus;
              default "active";
              config false;
              description
                "Whether a rule is valid at the current time. ";
            }
            leaf aclSourceIp {
              type inet:ipv4-address-no-zone;
              default "0.0.0.0";
              description
                "Source IP address.";
              ext:support-filter "true";
            }
            leaf aclSrcWild {
              type inet:ipv4-address-no-zone;
              default "255.255.255.255";
              description
                "Wildcard mask of a source IP address. ";
              ext:support-filter "true";
            }
            leaf aclFragType {
              type aclFragmentType;
              description
                "Type of packet fragmentation.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            leaf vrfName {
              type leafref {
                path "/l3vpn:l3vpn/l3vpn:l3vpncomm/l3vpn:l3vpnInstances/l3vpn:l3vpnInstance/l3vpn:vrfName";
              }
              default "_public_";
              description
                "VPN instance name. Data packets can be filtered based on VPN instance names.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            leaf aclTimeName {
              type leafref {
                path "/timerange:timerange/timerange:timeRangeInstances/timerange:timeRangeInstance/timerange:timeRangeName";
              }
              description
                "Name of a time range in which an ACL rule takes effect. The value is a string of 1 to 32 characters and must start with an uppercase or lowercase letter.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            leaf aclRuleDescription {
              type string {
                length "1..127";
                pattern '[^\?\s](([^\?\s]*)|[^\t\?]*[^\?\s])';
              }
              description
                "Description about an ACL rule. The value cannot begin or end with a space.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            container aclRuleCnts {
              config false;
              description
                "Number of times basic ACL rules are matched.";
              list aclRuleCnt {
                config false;
                description
                  "Information about the rule matched count.";
                leaf matchCount {
                  type uint64;
                  config false;
                  description
                    "Number of times when an user ACL rule is matched.";
                }
              }
            }
            leaf aclLogFlag {
              type boolean;
              default "false";
              description
                "Flag of logging matched data packets.";
            }
          }
        }
        container aclRuleAdv4s {
          description
            "List of advanced ACL rules. The advanced ACL rule group where these rules reside is of the numeric type or name type. For the advanced ACL rule group of the numeric type, the value ranges from 3000 to 3999.";
          list aclRuleAdv4 {
            key "aclRuleName";
            description
              "Advanced ACL rule, used to permit or deny packets. Other features can use the ACL control by referring to the rule group.";
            leaf aclRuleName {
              type string {
                length "1..32";
                pattern '[^\s\?]*';
              }
              must "../../../aclType='Advance'";
              description
                "Name of an advanced ACL rule. The rule name can be a number or character string without spaces, but cannot start with an underscore (_).";
            }
            leaf aclRuleID {
              type uint32 {
                range "0..4294967294";
              }
              description
                "ID of an advanced ACL rule in configuration mode.";
              ext:support-filter "true";
            }
            leaf aclAction {
              type aclRuleAction;
              mandatory true;
              description
                "Matching mode of advanced ACL rules. The available options are Permit and Deny.";
              ext:support-filter "true";
            }
            leaf aclActiveStatus {
              type pub-type:rowStatus;
              default "active";
              config false;
              description
                "Whether a rule is valid at the current time.";
            }
            leaf aclProtocol {
              type uint8;
              mandatory true;
              description
                "Protocol type value ((0: any ipv4 protocol; 1: icmp; 2: igmp; 4: ipinip; 6: tcp; 17: udp; 47: gre; 89: ospf). ";
              ext:support-filter "true";
              ext:value-replace {
                ext:item  "0" {
                  ext:meaning "IP";
                }
                ext:item  "1" {
                  ext:meaning "ICMP";
                }
                ext:item  "2" {
                  ext:meaning "IGMP";
                }
                ext:item  "4" {
                  ext:meaning "IPINIP";
                }
                ext:item  "6" {
                  ext:meaning "TCP";
                }
                ext:item  "17" {
                  ext:meaning "UDP";
                }
                ext:item  "47" {
                  ext:meaning "GRE";
                }
                ext:item  "89" {
                  ext:meaning "OSPF";
                }
              }
            }
            leaf aclSourceIp {
              when "not(../aclSPoolName)";
              type inet:ipv4-address-no-zone;
              default "0.0.0.0";
              description
                "Source IP address.";
              ext:support-filter "true";
            }
            leaf aclSrcWild {
              when "not(../aclSPoolName)";
              type inet:ipv4-address-no-zone;
              default "255.255.255.255";
              description
                "Wildcard mask of the source IP address. ";
              ext:support-filter "true";
            }
            leaf aclSPoolName {
              type leafref {
                path "/acl/aclPools/aclPool/aclPoolName";
              }
              description
                "Name of a source pool.";
              ext:allowDelete "true";
            }
            leaf aclDestIp {
              when "not(../aclDPoolName)";
              type inet:ipv4-address-no-zone;
              default "0.0.0.0";
              description
                "Destination IP address.";
              ext:support-filter "true";
            }
            leaf aclDestWild {
              when "not(../aclDPoolName)";
              type inet:ipv4-address-no-zone;
              default "255.255.255.255";
              description
                "Wildcard mask of a destination IP address.";
              ext:support-filter "true";
            }
            leaf aclDPoolName {
              type leafref {
                path "/acl/aclPools/aclPool/aclPoolName";
              }
              description
                "Name of a destination pool.";
              ext:allowDelete "true";
            }
            leaf aclSrcPortOp {
              when "(../aclProtocol=6 or ../aclProtocol=17) and not(../aclSPortPoolName)";
              type aclRangeType;
              must "../aclSrcPortBegin or ../aclSrcPortEnd";
              description
                "Range type of the source port.";
              ext:allowDelete "true";
            }
            leaf aclSrcPortBegin {
              type uint16 {
                range "0..65535";
              }
              must "(../aclSrcPortOp='gt' and ../aclSrcPortBegin!=65535) or (../aclSrcPortOp='eq' or ../aclSrcPortOp='range')";
              description
                "Start port number of the source port.";
              ext:allowDelete "true";
            }
            leaf aclSrcPortEnd {
              type uint16 {
                range "0..65535";
              }
              must "(../aclSrcPortOp='lt' and ../aclSrcPortEnd!=0) or (../aclSrcPortOp='range')";
              description
                "End port number of the source port.";
              ext:allowDelete "true";
            }
            leaf aclSPortPoolName {
              when "not(../aclProtocol!=6 and ../aclProtocol!=17) or ../aclProtocol=17 or ../aclProtocol=6";
              type leafref {
                path "/acl/aclPortPools/aclPortPool/aclPortPoolName";
              }
              description
                "Name of a source port pool.";
              ext:allowDelete "true";
            }
            leaf aclDestPortOp {
              when "not(../aclDPortPoolName or ../aclProtocol!=6 and ../aclProtocol!=17) or (../aclProtocol=17 and not(../aclDPortPoolName)) or (../aclProtocol=6 and not(../aclDPortPoolName))";
              type aclRangeType;
              must "../aclDestPortB or ../aclDestPortE";
              description
                "Range type of the destination port.";
              ext:allowDelete "true";
            }
            leaf aclDestPortB {
              type uint16 {
                range "0..65535";
              }
              must "(../aclDestPortOp='gt' and ../aclDestPortB!=65535) or (../aclDestPortOp='eq' or ../aclDestPortOp='range')";
              description
                "Start port number of the destination port.";
              ext:allowDelete "true";
            }
            leaf aclDestPortE {
              type uint16 {
                range "0..65535";
              }
              must "(../aclDestPortOp='lt' and ../aclDestPortE!=0) or (../aclDestPortOp='range')";
              description
                "End port of the destination port.";
              ext:allowDelete "true";
            }
            leaf aclDPortPoolName {
              when "not(../aclProtocol!=6 and ../aclProtocol!=17) or ../aclProtocol=6";
              type leafref {
                path "/acl/aclPortPools/aclPortPool/aclPortPoolName";
              }
              description
                "Name of a destination port pool.";
              ext:allowDelete "true";
            }
            leaf aclFragType {
              type aclFragmentType;
              description
                "Type of packet fragmentation.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            leaf aclPrecedence {
              when "not(../aclDscp)";
              type uint8 {
                range "0..7";
              }
              description
                "Data packets can be filtered based on the priority field.";
              ext:allowDelete "true";
            }
            leaf aclTos {
              when "not(../aclDscp)";
              type uint8 {
                range "0..15";
              }
              description
                "ToS value on which data packet filtering is based.";
              ext:allowDelete "true";
            }
            leaf aclDscp {
              when "not(../aclPrecedence) and not(../aclTos or ../aclPrecedence or ../aclTos)";
              type uint8 {
                range "0..63";
              }
              description
                "Differentiated Services Code Point.";
              ext:allowDelete "true";
            }
            leaf aclIcmpName {
              when "../aclProtocol=1";
              type ICMPNAME;
              default "unconfigured";
              description
                "ICMP name.";
            }
            leaf aclIcmpType {
              when "../aclProtocol=1";
              type uint16 {
                range "0..255";
              }
              must "((../aclIcmpName='address-mask-reply' and ../aclIcmpType=18) or (../aclIcmpName='address-mask-request' and ../aclIcmpType=17) or (../aclIcmpName='echo' and ../aclIcmpType=8) or (../aclIcmpName='echo-reply' and ../aclIcmpType=0) or (../aclIcmpName='fragmentneed-DFset' and ../aclIcmpType=3) or (../aclIcmpName='host-redirect' and ../aclIcmpType=5) or (../aclIcmpName='host-tos-redirect' and ../aclIcmpType=5) or (../aclIcmpName='host-unreachable' and ../aclIcmpType=3) or (../aclIcmpName='information-reply' and ../aclIcmpType=16) or (../aclIcmpName='information-request' and ../aclIcmpType=15) or (../aclIcmpName='net-redirect' and ../aclIcmpType=5) or (../aclIcmpName='net-tos-redirect' and ../aclIcmpType=5) or (../aclIcmpName='net-unreachable' and ../aclIcmpType=3) or (../aclIcmpName='parameter-problem' and ../aclIcmpType=12) or (../aclIcmpName='port-unreachable' and ../aclIcmpType=3) or (../aclIcmpName='protocol-unreachable' and ../aclIcmpType=3) or (../aclIcmpName='reassembly-timeout' and ../aclIcmpType=11) or (../aclIcmpName='source-quench' and ../aclIcmpType=4) or (../aclIcmpName='source-route-failed' and ../aclIcmpType=3) or (../aclIcmpName='timestamp-reply' and ../aclIcmpType=14) or (../aclIcmpName='timestamp-request' and ../aclIcmpType=13) or (../aclIcmpName='ttl-exceeded' and ../aclIcmpType=11) or not(../aclIcmpName='address-mask-reply' or ../aclIcmpName='address-mask-request' or ../aclIcmpName='echo' or ../aclIcmpName='echo-reply' or ../aclIcmpName='fragmentneed-DFset' or ../aclIcmpName='host-redirect' or ../aclIcmpName='host-tos-redirect' or ../aclIcmpName='host-unreachable' or ../aclIcmpName='information-reply' or ../aclIcmpName='information-request' or ../aclIcmpName='net-redirect' or ../aclIcmpName='net-tos-redirect' or ../aclIcmpName='net-unreachable' or ../aclIcmpName='parameter-problem' or ../aclIcmpName='port-unreachable' or ../aclIcmpName='protocol-unreachable' or ../aclIcmpName='reassembly-timeout' or ../aclIcmpName='source-quench' or ../aclIcmpName='source-route-failed' or ../aclIcmpName='timestamp-reply' or ../aclIcmpName='timestamp-request' or ../aclIcmpName='ttl-exceeded' or ../aclIcmpName='unconfigured')) and (../aclIcmpCode)";
              description
                "ICMP type. This parameter is available only when the packet protocol is ICMP. If this parameter is not set, packets of all ICMP types are matched.";
              ext:allowDelete "true";
            }
            leaf aclIcmpCode {
              when "../aclProtocol=1";
              type uint16 {
                range "0..255";
              }
              must "((../aclIcmpName='address-mask-reply' and ../aclIcmpCode=0) or (../aclIcmpName='address-mask-request' and ../aclIcmpCode=0) or (../aclIcmpName='echo' and ../aclIcmpCode=0) or (../aclIcmpName='echo-reply' and ../aclIcmpCode=0) or (../aclIcmpName='fragmentneed-DFset' and ../aclIcmpCode=4) or (../aclIcmpName='host-redirect' and ../aclIcmpCode=1) or (../aclIcmpName='host-tos-redirect' and ../aclIcmpCode=3) or (../aclIcmpName='host-unreachable' and ../aclIcmpCode=1) or (../aclIcmpName='information-reply' and ../aclIcmpCode=0) or (../aclIcmpName='information-request' and ../aclIcmpCode=0) or (../aclIcmpName='net-redirect' and ../aclIcmpCode=0) or (../aclIcmpName='net-tos-redirect' and ../aclIcmpCode=2) or (../aclIcmpName='net-unreachable' and ../aclIcmpCode=0) or (../aclIcmpName='parameter-problem' and ../aclIcmpCode=0) or (../aclIcmpName='port-unreachable' and ../aclIcmpCode=3) or (../aclIcmpName='protocol-unreachable' and ../aclIcmpCode=2) or (../aclIcmpName='reassembly-timeout' and ../aclIcmpCode=1) or (../aclIcmpName='source-quench' and ../aclIcmpCode=0) or (../aclIcmpName='source-route-failed' and ../aclIcmpCode=5) or (../aclIcmpName='timestamp-reply' and ../aclIcmpCode=0) or (../aclIcmpName='timestamp-request' and ../aclIcmpCode=0) or (../aclIcmpName='ttl-exceeded' and ../aclIcmpCode=0) or not(../aclIcmpName='address-mask-reply' or ../aclIcmpName='address-mask-request' or ../aclIcmpName='echo' or ../aclIcmpName='echo-reply' or ../aclIcmpName='fragmentneed-DFset' or ../aclIcmpName='host-redirect' or ../aclIcmpName='host-tos-redirect' or ../aclIcmpName='host-unreachable' or ../aclIcmpName='information-reply' or ../aclIcmpName='information-request' or ../aclIcmpName='net-redirect' or ../aclIcmpName='net-tos-redirect' or ../aclIcmpName='net-unreachable' or ../aclIcmpName='parameter-problem' or ../aclIcmpName='port-unreachable' or ../aclIcmpName='protocol-unreachable' or ../aclIcmpName='reassembly-timeout' or ../aclIcmpName='source-quench' or ../aclIcmpName='source-route-failed' or ../aclIcmpName='timestamp-reply' or ../aclIcmpName='timestamp-request' or ../aclIcmpName='ttl-exceeded' or ../aclIcmpName='unconfigured')) and (../aclIcmpType)";
              description
                "ICMP message code. Data packets can be filtered based on the ICMP message code.";
              ext:allowDelete "true";
            }
            leaf aclTtlExpired {
              type boolean;
              default "false";
              description
                "Whether TTL Expired is matched, with the TTL value of 1.";
              ext:allowDelete "true";
            }
            leaf vrfName {
              type leafref {
                path "/l3vpn:l3vpn/l3vpn:l3vpncomm/l3vpn:l3vpnInstances/l3vpn:l3vpnInstance/l3vpn:vrfName";
              }
              default "_public_";
              description
                "VPN instance name. Data packets can be filtered based on VPN instance names.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            leaf aclSynFlag {
              when "../aclProtocol=6";
              type uint8 {
                range "0..63";
              }
              must "../aclEstablished='false' or (not(../aclEstablished))";
              description
                "TCP header flag.";
              ext:allowDelete "true";
            }
            leaf aclTcpFlagMask {
              when "../aclSynFlag and ../aclProtocol=6";
              type uint16 {
                range "0..63";
              }
              description
                "Mask of TCP header flag.";
              ext:allowDelete "true";
            }
            leaf aclEstablished {
              when "../aclProtocol=6";
              type boolean;
              must "not(../aclSynFlag) or (../aclSynFlag and ../aclEstablished='false')";
              default "false";
              description
                "Match established connections.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            leaf aclTimeName {
              type leafref {
                path "/timerange:timerange/timerange:timeRangeInstances/timerange:timeRangeInstance/timerange:timeRangeName";
              }
              description
                "Name of a time range in which an ACL rule takes effect. The value is a string of 1 to 32 characters and must start with an uppercase or lowercase letter.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            leaf aclRuleDescription {
              type string {
                length "1..127";
                pattern '[^\?\s](([^\?\s]*)|[^\t\?]*[^\?\s])';
              }
              description
                "Description about an ACL rule. The value cannot begin or end with a space.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            leaf aclIgmpType {
              when "../aclProtocol=2";
              type uint16 {
                range "0..255";
              }
              description
                "Internet Group Management Protocol.";
              ext:allowDelete "true";
              ext:value-replace {
                ext:item  "17" {
                  ext:meaning "host-query";
                }
                ext:item  "18" {
                  ext:meaning "v1host-report";
                }
                ext:item  "22" {
                  ext:meaning "v2host-report";
                }
                ext:item  "23" {
                  ext:meaning "v2leave-group";
                }
                ext:item  "30" {
                  ext:meaning "mtrace-resp";
                }
                ext:item  "31" {
                  ext:meaning "mtrace-route";
                }
                ext:item  "34" {
                  ext:meaning "v3host-report";
                }
                ext:item  "48" {
                  ext:meaning "mrouter-adver";
                }
                ext:item  "49" {
                  ext:meaning "mrouter-solic";
                }
                ext:item  "50" {
                  ext:meaning "mrouter-termi";
                }
              }
            }
            container aclRuleCnts {
              config false;
              description
                "Number of times advanced ACL rules are matched.";
              list aclRuleCnt {
                config false;
                description
                  "Information about the rule matched count.";
                leaf matchCount {
                  type uint64;
                  config false;
                  description
                    "Number of times when an user ACL rule is matched.";
                }
              }
            }
            leaf aclLogFlag {
              type boolean;
              default "false";
              description
                "Flag of logging matched data packets.";
            }
          }
        }
        container aclRuleEths {
          description
            "List of Ethernet frame header-based ACL rules. The ACL rule group where these rules reside is of the numeric type or name type. For the Ethernet frame header-based ACL rule group of the numeric type, the value ranges from 4000 to 4999.";
          list aclRuleEth {
            key "aclRuleName";
            description
              "Ethernet frame header-based ACL rule, used to permit or deny packets. Other features can use these rules through a rule group to match source IP addresses.";
            leaf aclRuleName {
              type string {
                length "1..32";
                pattern '[^\s\?]*';
              }
              must "../../../aclType='Link'";
              description
                "Name of an Ethernet frame header-based ACL rule. The rule name can be a number or character string without spaces, but cannot start with an underscore (_).";
            }
            leaf aclRuleID {
              type uint32 {
                range "0..4294967294";
              }
              description
                "ID of an Ethernet frame header-based ACL rule in configuration mode.";
              ext:support-filter "true";
            }
            leaf aclAction {
              type aclRuleAction;
              mandatory true;
              description
                "Matching mode of Ethernet frame header-based ACL rules. The available options are Permit and Deny.";
              ext:support-filter "true";
            }
            leaf aclActiveStatus {
              type pub-type:rowStatus;
              default "active";
              config false;
              description
                "Whether a rule is valid at the current time.";
            }
            leaf aclFramType {
              type string {
                length "3..6";
                pattern '0[xX][a-fA-F0-9]{1,4}';
              }
              default "0x0";
              description
                "Type of Layer 2 Ethernet frame header protocols. Value range: [0x0, 0xffff].";
              ext:allowDelete "true";
            }
            leaf aclFramMask {
              when "../../../aclNumOrName!=99999";
              type string {
                length "3..6";
                pattern '0[xX][a-fA-F0-9]{1,4}';
              }
              must "../aclFramType";
              default "0xffff";
              description
                "Mask of the Layer 2 Ethernet frame header protocols. Value range: [0x0, 0xffff].";
              ext:allowDelete "true";
            }
            leaf aclSrcMac {
              type pub-type:macAddress {
                length "0..14";
                pattern '[0-9a-fA-F]{4}(-[0-9a-fA-F]{4}){2}';
              }
              default "0000-0000-0000";
              description
                "Source MAC address of an Ethernet frame. Example:: 1-1-1, 0001-0001-0001.";
            }
            leaf aclSrcMacMask {
              type pub-type:macAddress {
                length "0..14";
                pattern '[0-9a-fA-F]{4}(-[0-9a-fA-F]{4}){2}';
              }
              default "0000-0000-0000";
              description
                "Source MAC address of an Ethernet frame. Example: 1-1-1, 0001-0001-0001.";
            }
            leaf aclDestMac {
              type pub-type:macAddress {
                length "0..14";
                pattern '[0-9a-fA-F]{4}(-[0-9a-fA-F]{4}){2}';
              }
              default "0000-0000-0000";
              description
                "Destination MAC address of an Ethernet frame. Example: 1-1-1, 0001-0001-0001.";
            }
            leaf aclDestMacMask {
              type pub-type:macAddress {
                length "0..14";
                pattern '[0-9a-fA-F]{4}(-[0-9a-fA-F]{4}){2}';
              }
              default "0000-0000-0000";
              description
                "Destination MAC address mask of an Ethernet frame. Example: 1-1-1, 0001-0001-0001.";
            }
            leaf aclVlanId {
              type uint16 {
                range "1..4094";
              }
              description
                "VLAN ID.";
              ext:allowDelete "true";
            }
            leaf aclVlanIdMask {
              type string {
                length "3..5";
                pattern '0[xX][a-fA-F0-9]{1,3}';
              }
              default "0xfff";
              description
                "VLAN ID mask. Value range: [0x0, 0xfff].";
              ext:allowDelete "true";
            }
            leaf acl8021p {
              type uint8 {
                range "0..7";
              }
              description
                "802.1p priority.";
              ext:allowDelete "true";
            }
            leaf aclCVlanId {
              type uint16 {
                range "1..4094";
              }
              description
                "CE-VLAN ID.";
              ext:allowDelete "true";
            }
            leaf aclCVlanIdMask {
              when "../aclCVlanId";
              type string {
                length "3..5";
                pattern '0[xX][a-fA-F0-9]{1,3}';
              }
              default "0xfff";
              description
                "CE-VLAN ID mask. Value range: [0x0, 0xfff].";
              ext:allowDelete "true";
            }
            leaf aclCVlan8021p {
              type uint8 {
                range "0..7";
              }
              description
                "802.1p priority in the CE-VLAN tag.";
              ext:allowDelete "true";
            }
            leaf aclDoubleTag {
              type boolean;
              description
                "Whether double tags are matched.";
            }
            leaf aclEncapType {
              type aclEncapType;
              description
                "Encapsulation type.";
              ext:allowDelete "true";
            }
            leaf aclTimeName {
              type leafref {
                path "/timerange:timerange/timerange:timeRangeInstances/timerange:timeRangeInstance/timerange:timeRangeName";
              }
              description
                "Name of a time range in which an ACL rule takes effect. The value is a string of 1 to 32 characters and must start with an uppercase or lowercase letter.";
              ext:allowDelete "true";
            }
            leaf aclRuleDescription {
              type string {
                length "1..127";
                pattern '[^\?\s](([^\?\s]*)|[^\t\?]*[^\?\s])';
              }
              description
                "Description about an ACL rule. The value cannot begin or end with a space.";
              ext:allowDelete "true";
            }
            container aclRuleCnts {
              config false;
              description
                "Number of times Ethernet frame header-based ACL rules are matched.";
              list aclRuleCnt {
                config false;
                description
                  "Information about the rule matched count.";
                leaf matchCount {
                  type uint64;
                  config false;
                  description
                    "Number of times when an user ACL rule is matched.";
                }
              }
            }
          }
        }
        container aclRuleUsers {
          description
            "List of user ACL rules. The USER ACL rule group where these rules reside is of the numeric type, with the value ranging from 5000 to 5999.";
          list aclRuleUser {
            key "aclRuleName";
            description
              "User ACL rule, used to permit or deny packets. Other features can use the ACL control by referring to the rule group.";
            leaf aclRuleName {
              type string {
                length "1..32";
                pattern '[^\s\?]*';
              }
              must "../../../aclType='User'";
              description
                "Name of a user ACL rule. The rule name can be a number or character string without spaces, but cannot start with an underscore (_).";
            }
            leaf aclRuleID {
              type uint32 {
                range "0..4294967294";
              }
              description
                "Rule ID.";
              ext:support-filter "true";
            }
            leaf aclAction {
              type aclRuleAction;
              mandatory true;
              description
                "Matching mode of interface-based ACL6 rules. The available options are Permit and Deny.";
              ext:support-filter "true";
            }
            leaf aclTimeName {
              type leafref {
                path "/timerange:timerange/timerange:timeRangeInstances/timerange:timeRangeInstance/timerange:timeRangeName";
              }
              description
                "Name of a time range in which an ACL rule takes effect. The value is a string of 1 to 32 characters and must start with an uppercase or lowercase letter.";
              ext:allowDelete "true";
            }
            leaf aclOffsetBegin {
              type aclOffsetBegin;
              must "(../ruleString1 and ../ruleString1Mask and ../offset1) or (../ruleString2 and ../ruleString2Mask and ../offset2) or (../ruleString3 and ../ruleString3Mask and ../offset3) or (../ruleString4 and ../ruleString4Mask and ../offset4)";
              description
                "Position of the start offset. The offset can start from the Layer 2 header, IPv4 header, or Layer 4 header.";
              ext:allowDelete "true";
            }
            leaf ruleString1 {
              type pub-type:hexBinary;
              must "../ruleString1 and ../ruleString1Mask and ../offset1";
              description
                "First match field value. Value range: [0x0, 0xffffffff].";
              ext:allowDelete "true";
            }
            leaf ruleString1Mask {
              type pub-type:hexBinary;
              must "../ruleString1 and ../ruleString1Mask and ../offset1";
              description
                "First match field mask. Value range: [0x0, 0xffffffff].";
              ext:allowDelete "true";
            }
            leaf offset1 {
              type uint8;
              must "../ruleString1 and ../ruleString1Mask and ((../aclOffsetBegin='l2-head' and (../offset1 mod 4 = 2) and ../offset1 >= 2 and ../offset1 <= 114) or (../aclOffsetBegin='ipv4-head' and (../offset1 mod 4 = 0) and ../offset1 >= 0 and ../offset1 <= 96) or (../aclOffsetBegin='l4-head' and (../offset1 mod 4 = 0) and ../offset1 >= 0 and ../offset1 <= 60))";
              description
                "First match field offset. When the offset starts from a Layer 2 header, the value ranges from 2 to 114, in the format of 4n+2. When the offset starts from an IPv4 header, the value ranges from 0 to 96, in the format of 4n. When the offset starts from a Layer 4 header, the value ranges from 0 to 60, in the format of 4n. (n=0, 1, 2...)";
              ext:allowDelete "true";
            }
            leaf ruleString2 {
              type pub-type:hexBinary;
              must "../ruleString2 and ../ruleString2Mask and ../offset2";
              description
                "Second match field value. Value range: [0x0, 0xffffffff].";
              ext:allowDelete "true";
            }
            leaf ruleString2Mask {
              type pub-type:hexBinary;
              must "../ruleString2 and ../ruleString2Mask and ../offset2";
              description
                "Second match field mask. Value range: [0x0, 0xffffffff].";
              ext:allowDelete "true";
            }
            leaf offset2 {
              type uint8;
              must "../ruleString2 and ../ruleString2Mask and ((../aclOffsetBegin='l2-head' and (../offset2 mod 4 = 2) and ../offset2 >= 2 and ../offset2 <= 114) or (../aclOffsetBegin='ipv4-head' and (../offset2 mod 4 = 0) and ../offset2 >= 0 and ../offset2 <= 96) or (../aclOffsetBegin='l4-head' and (../offset2 mod 4 = 0) and ../offset2 >= 0 and ../offset2 <= 60))";
              description
                "Second match field offset. When the offset starts from a Layer 2 header, the value ranges from 2 to 114, in the format of 4n+2. When the offset starts from an IPv4 header, the value ranges from 0 to 96, in the format of 4n. When the offset starts from a Layer 4 header, the value ranges from 0 to 60, in the format of 4n. (n=0, 1, 2...)";
              ext:allowDelete "true";
            }
            leaf ruleString3 {
              type pub-type:hexBinary;
              must "../ruleString3 and ../ruleString3Mask and ../offset3";
              description
                "Third match field value. Value range: [0x0, 0xffffffff].";
              ext:allowDelete "true";
            }
            leaf ruleString3Mask {
              type pub-type:hexBinary;
              must "../ruleString3 and ../ruleString3Mask and ../offset3";
              description
                "Third match field mask. Value range: [0x0, 0xffffffff].";
              ext:allowDelete "true";
            }
            leaf offset3 {
              type uint8;
              must "../ruleString3 and ../ruleString3Mask and ((../aclOffsetBegin='l2-head' and (../offset3 mod 4 = 2) and ../offset3 >= 2 and ../offset3 <= 114) or (../aclOffsetBegin='ipv4-head' and (../offset3 mod 4 = 0) and ../offset3 >= 0 and ../offset3 <= 96) or (../aclOffsetBegin='l4-head' and (../offset3 mod 4 = 0) and ../offset3 >= 0 and ../offset3 <= 60))";
              description
                "Third match field offset. When the offset starts from a Layer 2 header, the value ranges from 2 to 114, in the format of 4n+2. When the offset starts from an IPv4 header, the value ranges from 0 to 96, in the format of 4n. When the offset starts from a Layer 4 header, the value ranges from 0 to 60, in the format of 4n. (n=0, 1, 2...)";
              ext:allowDelete "true";
            }
            leaf ruleString4 {
              type pub-type:hexBinary;
              must "../ruleString4 and ../ruleString4Mask and ../offset4";
              description
                "Fourth match field value. Value range: [0x0, 0xffffffff].";
              ext:allowDelete "true";
            }
            leaf ruleString4Mask {
              type pub-type:hexBinary;
              must "../ruleString4 and ../ruleString4Mask and ../offset4";
              description
                "Fourth match field mask. Value range: [0x0, 0xffffffff].";
              ext:allowDelete "true";
            }
            leaf offset4 {
              type uint8;
              must "../ruleString4 and ../ruleString4Mask and ((../aclOffsetBegin='l2-head' and (../offset4 mod 4 = 2) and ../offset4 >= 2 and ../offset4 <= 114) or (../aclOffsetBegin='ipv4-head' and (../offset4 mod 4 = 0) and ../offset4 >= 0 and ../offset4 <= 96) or (../aclOffsetBegin='l4-head' and (../offset4 mod 4 = 0) and ../offset4 >= 0 and ../offset4 <= 60))";
              description
                "Fourth match field offset. When the offset starts from a Layer 2 header, the value ranges from 2 to 114, in the format of 4n+2. When the offset starts from an IPv4 header, the value ranges from 0 to 96, in the format of 4n. When the offset starts from a Layer 4 header, the value ranges from 0 to 60, in the format of 4n. (n=0, 1, 2...)";
              ext:allowDelete "true";
            }
            leaf aclActiveStatus {
              type pub-type:rowStatus;
              default "active";
              config false;
              description
                "Whether a rule is valid at the current time.";
            }
            leaf aclRuleDescription {
              type string {
                length "1..127";
                pattern '[^\?\s](([^\?\s]*)|[^\t\?]*[^\?\s])';
              }
              description
                "Description about an ACL rule. The value cannot begin or end with a space.";
              ext:allowDelete "true";
            }
            container aclRuleCnts {
              config false;
              description
                "List of the matching count of all user ACL rules.";
              list aclRuleCnt {
                config false;
                description
                  "Information about the rule matched count.";
                leaf matchCount {
                  type uint64;
                  config false;
                  description
                    "Number of times when an user ACL rule is matched.";
                }
              }
            }
          }
        }
        container aclRuleArps {
          description
            "List of ARP ACL rules. The ARP ACL rule group where these rules reside is of the numeric type, with the value ranging from 23000 to 23999.";
          list aclRuleArp {
            key "aclRuleName";
            description
              "ARP ACL rule, used to permit or deny packets. Other features can use the ACL control by referring to the rule group.";
            leaf aclRuleName {
              type string {
                length "1..32";
                pattern '[^\s\?]*';
              }
              must "../../../aclType='ARP'";
              description
                "Name of a ARP ACL rule.User can specify number or string without spaces,But start with _is not permitted.";
            }
            leaf aclRuleID {
              type uint32 {
                range "0..4294967294";
              }
              description
                "Rule ID.";
              ext:support-filter "true";
            }
            leaf aclAction {
              type aclRuleAction;
              mandatory true;
              description
                "Matching mode of interface-based ACL rules. The available options are Permit and Deny.";
              ext:support-filter "true";
            }
            leaf aclTimeName {
              type leafref {
                path "/timerange:timerange/timerange:timeRangeInstances/timerange:timeRangeInstance/timerange:timeRangeName";
              }
              description
                "Name of a period of time after which an ACL rule expires. The value is a string of 1 to 32 characters, starting with a lower- or upper-case English letter.";
              ext:allowDelete "true";
            }
            leaf aclPacketMode {
              type aclPacketMode;
              mandatory true;
              description
                "Packet type of ARP packet, request or reply.";
            }
            leaf aclSourceIp {
              type inet:ipv4-address-no-zone;
              default "0.0.0.0";
              description
                "Source IP address.";
            }
            leaf aclSrcWild {
              type inet:ipv4-address-no-zone;
              default "255.255.255.255";
              description
                "Wildcard mask of the source IP address. ";
            }
            leaf aclDestIp {
              when "not(../aclPacketMode='request')";
              type inet:ipv4-address-no-zone;
              default "0.0.0.0";
              description
                "Destination IP address.";
            }
            leaf aclDestWild {
              when "not(../aclPacketMode='request')";
              type inet:ipv4-address-no-zone;
              default "255.255.255.255";
              description
                "Wildcard mask of the destination IP address.";
            }
            leaf aclSrcMac {
              type pub-type:macAddress {
                length "0..14";
                pattern '[0-9a-fA-F]{4}(-[0-9a-fA-F]{4}){2}';
              }
              default "0000-0000-0000";
              description
                "Source MAC address of the ARP packet.Input foramt sample: 1-1-1, 0001-0001-0001.";
            }
            leaf aclSrcMacMask {
              type pub-type:macAddress {
                length "0..14";
                pattern '[0-9a-fA-F]{4}(-[0-9a-fA-F]{4}){2}';
              }
              default "0000-0000-0000";
              description
                "Mask of the source MAC address.Input foramt sample: 1-1-1, 0001-0001-0001.";
            }
            leaf aclDestMac {
              when "not(../aclPacketMode='request')";
              type pub-type:macAddress {
                length "0..14";
                pattern '[0-9a-fA-F]{4}(-[0-9a-fA-F]{4}){2}';
              }
              default "0000-0000-0000";
              description
                "Destination MAC address of the ARP packet.Input foramt sample: 1-1-1, 0001-0001-0001.";
            }
            leaf aclDestMacMask {
              when "not(../aclPacketMode='request')";
              type pub-type:macAddress {
                length "0..14";
                pattern '[0-9a-fA-F]{4}(-[0-9a-fA-F]{4}){2}';
              }
              default "0000-0000-0000";
              description
                "Mask of the destination MAC address.Input foramt sample: 1-1-1, 0001-0001-0001.";
            }
            leaf aclActiveStatus {
              type pub-type:rowStatus;
              default "active";
              config false;
              description
                "Indicates whether a rule is valid at the current time. ";
            }
            leaf aclRuleDescription {
              type string {
                length "1..127";
                pattern '[^\?\s](([^\?\s]*)|[^\t\?]*[^\?\s])';
              }
              description
                "Description about an ACL rule. The value cannot begin or end with a space.";
              ext:allowDelete "true";
            }
            container aclRuleCnts {
              config false;
              description
                "List of the matching count of all user ACL rules.";
              list aclRuleCnt {
                config false;
                description
                  "Information about the rule matched count.";
                leaf matchCount {
                  type uint64;
                  config false;
                  description
                    "Number of times when an user ACL rule is matched.";
                }
              }
            }
          }
        }
      }
    }
    container aclGroup6s {
      description
        "List of ACL6 rule groups.";
      list aclGroup6 {
        key "aclNumOrName";
        description
          "ACL6 rule group, which is a collection of multiple ACL6 rules. Other features can use the ACL6 control by referring to the ACL6 rule group name.";
        leaf aclNumOrName {
          type acl6NumOrName {
            length "1..32";
            pattern '([1-3]\d{3})|([a-zA-Z]([^\s]*))';
          }
          description
            "ACL6 number or name. An ACL6 number ranges from 1000 to 3999. An ACL name must start with a letter, spaces not supported. The number of an interface-based ACL6 ranges from 1000 to 1999. The number of a basic ACL6 ranges from 2000 to 2999. The number of an advanced ACL6 ranges from 3000 to 3999, and an advanced ACL can start with a letter.
";
          ext:support-filter "true";
        }
        leaf aclType {
          type acl6GroupType;
          description
            "ACL6 Type.";
          ext:support-filter "true";
        }
        leaf aclDescription {
          type string {
            length "1..127";
            pattern '[^\?\s](([^\?\s]*)|[^\t\?]*[^\?\s])';
          }
          description
            "Description about an ACL6 rule group. The value cannot begin or end with a space.";
          ext:allowDelete "true";
        }
        container aclRuleBas6s {
          description
            "List of basic ACL6 rules. The ACL6 rule group where these rules reside is of the numeric type or name type. For the basic ACL6 rule group of the numeric type, the value ranges from 2000 to 2999.";
          list aclRuleBas6 {
            key "aclRuleName";
            description
              "Basic ACL6 rule, used to permit or deny packets. Other features can use the ACL control by referring to the rule group.";
            leaf aclRuleName {
              type string {
                length "1..32";
                pattern '[^\s\?]*';
              }
              must "../../../aclType='Basic'";
              description
                "Name of an ACL6 rule. The rule name can be a number or character string without spaces, but cannot start with an underscore (_).";
            }
            leaf aclRuleID {
              type uint32 {
                range "0..4294967294";
              }
              description
                "ID of an ACL6 rule in configuration mode.";
              ext:support-filter "true";
            }
            leaf aclAction {
              type aclRuleAction;
              mandatory true;
              description
                "Matching mode of ACL6 rules. The available options are Permit and Deny.";
              ext:support-filter "true";
            }
            leaf aclActiveStatus {
              type pub-type:rowStatus;
              default "active";
              config false;
              description
                "Whether a rule is valid at the current time.";
            }
            leaf aclSourceIp {
              type inet:ipv6-address-no-zone;
              description
                "Source IPv6 address.";
            }
            leaf aclSrcMaskMode {
              type aclMaskMode;
              default "PositiveLength";
              description
                "Mask mode of an IPv6 address.";
              ext:allowDelete "true";
            }
            leaf aclSrcWild {
              when "../aclSrcMaskMode='PositiveLength'";
              type uint32 {
                range "1..128";
              }
              description
                "Source IPv6 address mask. ";
              ext:allowDelete "true";
            }
            leaf aclSourceIpMask {
              when "../aclSrcMaskMode='Negative'";
              type inet:ipv6-address-no-zone;
              description
                "Wildcard mask of a source IPv6 address.";
            }
            leaf aclFragType {
              type aclFragmentIPv6Type;
              must "((../aclFragType='fragment' or ../aclFragType='clear_fragment') )";
              description
                "Type of packet fragmentation.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            leaf vrfName {
              type leafref {
                path "/l3vpn:l3vpn/l3vpn:l3vpncomm/l3vpn:l3vpnInstances/l3vpn:l3vpnInstance/l3vpn:vrfName";
              }
              default "_public_";
              description
                "VPN instance name. Data packets can be filtered based on VPN instance names.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            leaf aclTimeName {
              type leafref {
                path "/timerange:timerange/timerange:timeRangeInstances/timerange:timeRangeInstance/timerange:timeRangeName";
              }
              description
                "Name of a time range in which an ACL rule takes effect. The value is a string of 1 to 32 characters and must start with an uppercase or lowercase letter.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            leaf aclRuleDescription {
              type string {
                length "1..127";
                pattern '[^\?\s](([^\?\s]*)|[^\t\?]*[^\?\s])';
              }
              description
                "Description about an ACL rule. The value cannot begin or end with a space.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            container acl6RuleCnts {
              config false;
              description
                "Number of times ACL6 rules are matched.";
              list acl6RuleCnt {
                config false;
                description
                  "Number of times interface-based ACL6 rules are matched.";
                leaf matchCount {
                  type uint64;
                  config false;
                  description
                    "Information about the rule matched count.";
                }
              }
            }
          }
        }
        container aclRuleAdv6s {
          description
            "List of advanced ACL6 rules. The ACL6 rule group where these rules reside is of the numeric type or name type. For the ACL6 rule group of the numeric type, the value ranges from 3000 to 3999.";
          list aclRuleAdv6 {
            key "aclRuleName";
            description
              "Advanced ACL6 rule, used to permit or deny packets. Other features can use the ACL control by referring to the rule group.";
            leaf aclRuleName {
              type string {
                length "1..32";
                pattern '[^\s\?]*';
              }
              must "../../../aclType='Advance'";
              description
                "Name of an advanced ACL6 rule. The rule name can be a number or character string without spaces, but cannot start with an underscore (_).";
            }
            leaf aclRuleID {
              type uint32 {
                range "0..4294967294";
              }
              description
                "ID of an advanced ACL6 rule in configuration mode.";
              ext:support-filter "true";
            }
            leaf aclAction {
              type aclRuleAction;
              mandatory true;
              description
                "Matching mode of advanced ACL6 rules. The available options are Permit and Deny.";
              ext:support-filter "true";
            }
            leaf aclActiveStatus {
              type pub-type:rowStatus;
              default "active";
              config false;
              description
                "Whether a rule is valid at the current time.";
            }
            leaf aclProtocol {
              type uint8;
              mandatory true;
              description
                "Protocol type value (0: any ipv6 protocol; 6: tcp; 17: udp; 47: gre; 50: ipv6-esp; 51: ipv6-ah; 58: icmpv6; 89: ospf). ";
              ext:support-filter "true";
              ext:value-replace {
                ext:item  "0" {
                  ext:meaning "IPV6";
                }
                ext:item  "6" {
                  ext:meaning "TCP";
                }
                ext:item  "17" {
                  ext:meaning "UDP";
                }
                ext:item  "47" {
                  ext:meaning "GRE";
                }
                ext:item  "50" {
                  ext:meaning "IPV6-ESP";
                }
                ext:item  "51" {
                  ext:meaning "IPV6-AH";
                }
                ext:item  "58" {
                  ext:meaning "ICMPV6";
                }
                ext:item  "89" {
                  ext:meaning "OSPF";
                }
              }
            }
            leaf aclSourceIp {
              type inet:ipv6-address-no-zone;
              description
                "Source IPv6 address.";
            }
            leaf aclSrcMaskMode {
              type aclMaskMode;
              default "PositiveLength";
              description
                "Mask mode of a source IPv6 address.";
              ext:allowDelete "true";
            }
            leaf aclSrcWild {
              when "not(not(../aclSrcMaskMode)) or ../aclSrcMaskMode='PositiveLength'";
              type uint32 {
                range "1..128";
              }
              description
                "Mask of the source IP address. ";
              ext:allowDelete "true";
            }
            leaf aclSourceIpMask {
              when "not(../aclSrcMaskMode='PositiveLength' or not(../aclSrcMaskMode))";
              type inet:ipv6-address-no-zone;
              description
                "Wildcard mask of a source IPv6 address.";
            }
            leaf aclDestIp {
              type inet:ipv6-address-no-zone;
              description
                "Destination IPv6 address.";
            }
            leaf aclDestMaskMode {
              type aclMaskMode;
              default "PositiveLength";
              description
                "Mask mode of a destination IPv6 address.";
              ext:allowDelete "true";
            }
            leaf aclDestWild {
              when "not(not(../aclDestMaskMode)) or ../aclDestMaskMode='PositiveLength'";
              type uint32 {
                range "1..128";
              }
              description
                "Mask of the destination IP address.";
              ext:allowDelete "true";
            }
            leaf aclDestIpMask {
              when "not(../aclDestMaskMode='PositiveLength' or not(../aclDestMaskMode))";
              type inet:ipv6-address-no-zone;
              description
                "Wildcard mask of a destination IPv6 address.";
            }
            leaf aclSrcPortOp {
              when "../aclProtocol=17 or ../aclProtocol=6";
              type aclRangeType;
              must "../aclSrcPortBegin or ../aclSrcPortEnd";
              description
                "Range type of the source port.";
              ext:allowDelete "true";
            }
            leaf aclSrcPortBegin {
              type uint16 {
                range "0..65535";
              }
              must "(../aclSrcPortOp='gt' and ../aclSrcPortBegin!=65535) or (../aclSrcPortOp='eq' or ../aclSrcPortOp='range')";
              description
                "Start port number of the source port.";
              ext:allowDelete "true";
            }
            leaf aclSrcPortEnd {
              type uint16 {
                range "0..65535";
              }
              must "(../aclSrcPortOp='lt' and ../aclSrcPortEnd!=0) or (../aclSrcPortOp='range')";
              description
                "End port number of the source port.";
              ext:allowDelete "true";
            }
            leaf aclDestPortOp {
              when "../aclProtocol=17 or ../aclProtocol=6";
              type aclRangeType;
              must "../aclDestPortB or ../aclDestPortE";
              description
                "Range type of the destination port.";
              ext:allowDelete "true";
            }
            leaf aclDestPortB {
              type uint16 {
                range "0..65535";
              }
              must "(../aclDestPortOp='gt' and ../aclDestPortB!=65535) or (../aclDestPortOp='eq' or ../aclDestPortOp='range')";
              description
                "Start port number of the destination port.";
              ext:allowDelete "true";
            }
            leaf aclDestPortE {
              type uint16 {
                range "0..65535";
              }
              must "(../aclDestPortOp='lt' and ../aclDestPortE!=0) or (../aclDestPortOp='range')";
              description
                "End port number of the destination port.";
              ext:allowDelete "true";
            }
            leaf aclFragType {
              type aclFragmentIPv6Type;
              must "((../aclFragType='fragment' or ../aclFragType='clear_fragment'))";
              description
                "Type of packet fragmentation.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            leaf aclDscp {
              type uint8 {
                range "0..63";
              }
              description
                "Value of the Differentiated Services Code Point (DSCP).";
              ext:allowDelete "true";
            }
            leaf aclIcmpName {
              when "../aclProtocol=58";
              type ICMP6NAME;
              default "unconfigured";
              description
                "ICMP Name.";
            }
            leaf aclIcmpType {
              when "../aclProtocol=58";
              type uint16 {
                range "0..255";
              }
              must "((../aclIcmpName='Redirect' and ../aclIcmpType=137) or (../aclIcmpName='echo' and ../aclIcmpType=128) or (../aclIcmpName='echo-reply' and ../aclIcmpType=129) or (../aclIcmpName='err-Header-field' and ../aclIcmpType=4) or (../aclIcmpName='frag-time-exceeded' and ../aclIcmpType=3) or (../aclIcmpName='hop-limit-exceeded' and ../aclIcmpType=3) or (../aclIcmpName='host-admin-prohib' and ../aclIcmpType=1) or (../aclIcmpName='host-unreachable' and ../aclIcmpType=1) or (../aclIcmpName='neighbor-advertisement' and ../aclIcmpType=136) or (../aclIcmpName='neighbor-solicitation' and ../aclIcmpType=135) or (../aclIcmpName='network-unreachable' and ../aclIcmpType=1) or (../aclIcmpName='packet-too-big' and ../aclIcmpType=2) or (../aclIcmpName='port-unreachable' and ../aclIcmpType=1) or (../aclIcmpName='router-advertisement' and ../aclIcmpType=134) or (../aclIcmpName='router-solicitation' and ../aclIcmpType=133) or (../aclIcmpName='unknown-ipv6-opt' and ../aclIcmpType=4) or (../aclIcmpName='unknown-next-hdr' and ../aclIcmpType=4) or not(../aclIcmpName='Redirect' or ../aclIcmpName='echo' or ../aclIcmpName='echo-reply' or ../aclIcmpName='err-Header-field' or ../aclIcmpName='frag-time-exceeded' or ../aclIcmpName='hop-limit-exceeded' or ../aclIcmpName='host-admin-prohib' or ../aclIcmpName='host-unreachable' or ../aclIcmpName='neighbor-advertisement' or ../aclIcmpName='neighbor-solicitation' or ../aclIcmpName='network-unreachable' or ../aclIcmpName='packet-too-big' or ../aclIcmpName='port-unreachable' or ../aclIcmpName='router-advertisement' or ../aclIcmpName='router-solicitation' or ../aclIcmpName='unconfigured' or ../aclIcmpName='unknown-ipv6-opt' or ../aclIcmpName='unknown-next-hdr')) and ../aclIcmpCode";
              description
                "ICMP type. This parameter is available only when the packet protocol is ICMP. If this parameter is not set, it indicates that the packets of all ICMP types can match.";
              ext:allowDelete "true";
            }
            leaf aclIcmpCode {
              when "../aclProtocol=58";
              type uint16 {
                range "0..255";
              }
              must "((../aclIcmpName='Redirect' and ../aclIcmpCode=0) or (../aclIcmpName='echo' and ../aclIcmpCode=0) or (../aclIcmpName='echo-reply' and ../aclIcmpCode=0) or (../aclIcmpName='err-Header-field' and ../aclIcmpCode=0) or (../aclIcmpName='frag-time-exceeded' and ../aclIcmpCode=1) or (../aclIcmpName='hop-limit-exceeded' and ../aclIcmpCode=0) or (../aclIcmpName='host-admin-prohib' and ../aclIcmpCode=1) or (../aclIcmpName='host-unreachable' and ../aclIcmpCode=3) or (../aclIcmpName='neighbor-advertisement' and ../aclIcmpCode=0) or (../aclIcmpName='neighbor-solicitation' and ../aclIcmpCode=0) or (../aclIcmpName='network-unreachable' and ../aclIcmpCode=0) or (../aclIcmpName='packet-too-big' and ../aclIcmpCode=0) or (../aclIcmpName='port-unreachable' and ../aclIcmpCode=4) or (../aclIcmpName='router-advertisement' and ../aclIcmpCode=0) or (../aclIcmpName='router-solicitation' and ../aclIcmpCode=0) or (../aclIcmpName='unknown-ipv6-opt' and ../aclIcmpCode=2) or (../aclIcmpName='unknown-next-hdr' and ../aclIcmpCode=1) or not(../aclIcmpName='Redirect' or ../aclIcmpName='echo' or ../aclIcmpName='echo-reply' or ../aclIcmpName='err-Header-field' or ../aclIcmpName='frag-time-exceeded' or ../aclIcmpName='hop-limit-exceeded' or ../aclIcmpName='host-admin-prohib' or ../aclIcmpName='host-unreachable' or ../aclIcmpName='neighbor-advertisement' or ../aclIcmpName='neighbor-solicitation' or ../aclIcmpName='network-unreachable' or ../aclIcmpName='packet-too-big' or ../aclIcmpName='port-unreachable' or ../aclIcmpName='router-advertisement' or ../aclIcmpName='router-solicitation' or ../aclIcmpName='unconfigured' or ../aclIcmpName='unknown-ipv6-opt' or ../aclIcmpName='unknown-next-hdr')) and ../aclIcmpType";
              description
                "ICMP message code. The data packets can be filtered on the basis of the ICMP message code.";
              ext:allowDelete "true";
            }
            leaf vrfName {
              type leafref {
                path "/l3vpn:l3vpn/l3vpn:l3vpncomm/l3vpn:l3vpnInstances/l3vpn:l3vpnInstance/l3vpn:vrfName";
              }
              default "_public_";
              description
                "VPN instance name. Data packets can be filtered based on VPN instance names.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            leaf aclTimeName {
              type leafref {
                path "/timerange:timerange/timerange:timeRangeInstances/timerange:timeRangeInstance/timerange:timeRangeName";
              }
              description
                "Name of a time range in which an ACL rule takes effect. The value is a string of 1 to 32 characters and must start with an uppercase or lowercase letter.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            leaf aclRuleDescription {
              type string {
                length "1..127";
                pattern '[^\?\s](([^\?\s]*)|[^\t\?]*[^\?\s])';
              }
              description
                "Description about an ACL rule. The value cannot begin or end with a space.";
              ext:support-filter "true";
              ext:allowDelete "true";
            }
            container acl6RuleCnts {
              config false;
              description
                "Number of times rules are matched.";
              list acl6RuleCnt {
                config false;
                description
                  "Number of times interface-based ACL6 rules are matched.";
                leaf matchCount {
                  type uint64;
                  config false;
                  description
                    "Information about the rule matched count.";
                }
              }
            }
          }
        }
        leaf aclStep {
          type uint32 {
            range "1..20";
          }
          default "5";
          description
            "Step of an ACL6 rule.";
          ext:allowDelete "true";
        }
      }
    }
    container aclPools {
      description
        "List of all ACL pools.";
      list aclPool {
        key "aclPoolName";
        max-elements  "256";
        description
          "ACL pool, which is a collection of IP addresses.";
        leaf aclPoolName {
          type string {
            length "1..32";
          }
          description
            "Name of an ACL pool.";
          ext:support-filter "true";
        }
        container aclPoolIps {
          description
            "List of all IP addresses for ACL pools.";
          list aclPoolIp {
            key "aclPoolIpAdd aclPoolIpMask";
            max-elements  "256";
            description
              "IP addresses in a pool.";
            leaf aclPoolIpAdd {
              type inet:ipv4-address-no-zone;
              description
                "IP address.";
            }
            leaf aclPoolIpMask {
              type inet:ipv4-address-no-zone;
              description
                "IP address wildcard mask.";
            }
          }
        }
      }
    }
    container aclPortPools {
      description
        "List of all ACL port pools.";
      list aclPortPool {
        key "aclPortPoolName";
        max-elements  "256";
        description
          "ACL port pool, which is a collection of port number range.";
        leaf aclPortPoolName {
          type string {
            length "1..32";
          }
          description
            "Name of an ACL port pool.";
          ext:support-filter "true";
        }
        container aclPorts {
          description
            "List of all port number range for ACL port pools.";
          list aclPort {
            key "aclPortOp aclPortBegin aclPortEnd";
            max-elements  "256";
            description
              "Port number range in a pool.";
            leaf aclPortOp {
              type aclRangeType;
              description
                "Range type of the port.";
            }
            leaf aclPortBegin {
              type uint16 {
                range "0..65535";
              }
              must "(../aclPortOp='range') or (../aclPortOp='eq') or (../aclPortOp='lt' and ../aclPortBegin=0) or (../aclPortOp='gt' and ../aclPortBegin!=65535)";
              description
                "Start port number of the port.";
            }
            leaf aclPortEnd {
              type uint16 {
                range "0..65535";
              }
              must "(../aclPortOp='range') or (../aclPortOp='eq' and ../aclPortEnd=../aclPortBegin) or (../aclPortOp='gt' and ../aclPortEnd=65535) or (../aclPortOp='lt' and ../aclPortEnd!=0)";
              description
                "End port number of the port.";
            }
          }
        }
      }
    }
  }
}
